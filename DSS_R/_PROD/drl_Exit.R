# ----------------------------------------------------------------------------------------
# R Script to train the Deep Learning Reinforcement model and Score data to derive decision
# ----------------------------------------------------------------------------------------
# Use initially generated data to start training process
# ----------------------------------------------------------------------------------------
# Decision whether to keep or close trade using Supervised
# Deep Learning Classification Modelling with two classes
#
start_run <- Sys.time()
# load libraries to use and custom functions from package lazytrade
library(readr)
library(magrittr)
library(dplyr)
library(h2o)
library(lazytrade)


#path to user repo:
path_user <- normalizePath(Sys.getenv('PATH_DSS'), winslash = '/')
path_repo <- normalizePath(Sys.getenv('PATH_DSS_Repo'), winslash = '/')

#path with the setup info
path_setup <- file.path(path_repo, 'DSS_Public', 'DSS_Setup')
#settings from options
ncpu <- as.numeric(Sys.getenv('OPT_AML_NCPU'))

#path with the data
path_data <- file.path(path_user, "_DATA")

chart_period <- as.numeric(Sys.getenv('OPT_MT_PerMin'))
#!!!Execute code below line by line

#absolute path to store model objects (useful when scheduling tasks)
path_model <- file.path(path_user, "_MODELS")
path_data <- file.path(path_user, "_DATA")

#absolute path with the data (choose MT4 directory where files are generated)
path_terminal <- normalizePath(Sys.getenv('PATH_T1'), winslash = '/')
#path to 3rd terminal to write duplicate data output
path_sbxs <- normalizePath(Sys.getenv('PATH_T3'), winslash = '/')

# check if the directory exists or create
if(!dir.exists(path_model)){dir.create(path_model)}
if(!dir.exists(path_data)){dir.create(path_data)}

# Vector of currency pairs
Pairs <- readLines(file.path(path_setup, '5_pairs.txt')) %>% 
  stringr::str_split(pattern = ',') %>% unlist()

# data containing information about already closed trades
DFT1 <- try(import_data(path_terminal, "OrdersResultsT1.csv"), silent = TRUE)

# start h2o virtual machine
h2o.init(nthreads = ncpu)

### Arrange into For loop for all symbols in use
for (SYMB in Pairs) {
  
  #SYMB = "USDJPY"
  #SYMB = "AUDUSD"
  #SYMB = "EURUSD"
  #SYMB = "ADAUSD"
  #SYMB = "XRPUSD"
  #SYMB = "GBPUSD"





#### Read the Initially Generated data... =================================================
#note: data should be generated by the mt4 robot DSS_DRL_Bot on Initialization

# data containing information about currently opened trades of the robot
drl_exit_data <- try(readr::read_csv(file.path(path_terminal, paste0("RLUnit",SYMB,"Exit.csv")), col_names = FALSE),silent = TRUE)

# aggregate this data and record it!
# write this dataset only if rds dataset not existing yet
if(!class(drl_exit_data)=='try-error' && !file.exists(file.path(path_data, paste0("drl_exit",SYMB,".rds")))){
  
  # store dataset to be able to retrain deep learning classification model
  readr::write_rds(drl_exit_data, file.path(path_data, paste0("drl_exit",SYMB,".rds")))
  #change the name of the dataset
  drl_exit_dataset_comb <- drl_exit_data
  
} else {
  drl_exit_data_upd <- readr::read_rds(file.path(path_data, paste0("drl_exit",SYMB,".rds")))
  
  # join data which was already collected to the one in the memory, check they are unique
  drl_exit_dataset_comb <- dplyr::bind_rows(drl_exit_data,drl_exit_data_upd) 
  drl_exit_dataset_comb <- unique(drl_exit_dataset_comb)
  
  # store this dataset to be able to retrain deep learning classification model
  readr::write_rds(drl_exit_dataset_comb, file.path(path_data, paste0("drl_exit",SYMB,".rds")))
  
}


# join the data from running trades with the data from closed orders (if any)
joined_DF <- dplyr::inner_join(drl_exit_dataset_comb, DFT1, by = c("X7" = "TicketNumber"))

## data from joined_DF can be used for model building!
# create classes!
DRL_exit_LBL <- joined_DF %>%
  # rule is to 'KEEP' if the trade was positive after the end of the trade
  # .. 'CLOSE' if opposite
  dplyr::mutate(LABEL = base::ifelse(Profit >= 0, "KEEP", "CLOSE")) %>% 
  #sort this data by col X7 (ticket) descending order
  dplyr::arrange(desc(X7))


## multiply column X3-X5 to value 'z' to make column abs.value min/max -100/100
# get value of one tick
symb_tick <- readr::read_csv(file.path(path_terminal, "TickSize_AI_RSIADX.csv"),col_names = FALSE) %>% 
  dplyr::filter(X1 == SYMB) %$% X2

# further manipulate data to 'shape' dataset PREDICTORS:
# X1 running profit
# X2 order type (1 - sell, 0 - buy)
# X3 num positions sell
# X4 num positions buy
# X5 distance TP
# X6 distance SL
# X7 order time in min
# X9-x11 RSI indicator
# Profit - final order profit (will not be used for modelling)

# X1 - will not be used for prediction
#DRL_exit_LBL$X1 <- DRL_exit_LBL$X1/symb_tick
# X2 - will be converted to be from 0 to 100
DRL_exit_LBL$X2 <- DRL_exit_LBL$X2*100

# remove non needed columns
DRL_exit_LBL_M <- DRL_exit_LBL %>% 
  dplyr::select(-(MagicNumber:OrderCloseTime)) %>% 
  dplyr::select(-Symbol) %>%
  #dplyr::select(-X7) %>% 
  dplyr::select(-OrderType) %>% 
  dplyr::mutate(across(LABEL, as.factor)) %>% 
  #limit data to max 2000 rows for faster calculation
  head(2000)


# do not start training if only one class or too little data
if (nrow(DRL_exit_LBL_M)!=0 && length(unique(DRL_exit_LBL_M$LABEL))!=1) {

  
  
  # dataset DRL_exit_LBL_M inspection [not used]
  # table(DRL_exit_LBL_M$LABEL)
  # balance classes
  KEEP <- which(DRL_exit_LBL_M$LABEL == "KEEP")
  CLOSE <- which(DRL_exit_LBL_M$LABEL == "CLOSE")
  

  
#### Fitting Deep Learning Net =================================================
# get this data into h2o:
drl_exit_df  <- h2o::as.h2o(x = DRL_exit_LBL_M, destination_frame = "drl_exit_df")
#' # performing Deep Learning Classification using the custom function auto clustered data
ModelDRLE <- h2o::h2o.deeplearning(
  model_id = paste0("DRL_EXIT", "_", SYMB),
  x = names(drl_exit_df[,c(1:6,8:11)]),
  y = "LABEL",
  training_frame = drl_exit_df,
  activation = "Tanh",
  overwrite_with_best_model = TRUE,
  autoencoder = FALSE,
  hidden = c(100, 100),
  loss = "Automatic",
  sparse = TRUE,
  l1 = 1e-4,
  distribution = "AUTO",
  stopping_metric = "AUTO",
  balance_classes = FALSE,
  epochs = 100)
#summary(ModelDRLC)
#h2o.performance(ModelDRLE)


#### Score new data using obtained Deep Learning Net ===========================
# clean data to use it for prediction
drl_exit_data$X2 <- drl_exit_data$X2*100

dfr_LBL <- drl_exit_data %>% 
  mutate(LABEL = "KEEP") %>% 
  select(-X7) %>% 
  dplyr::mutate(across(LABEL, as.factor))

# # load the dataset to h2o
 test  <- h2o::as.h2o(x = dfr_LBL, destination_frame = "test")
# 
# # retrieve the predicted value of the market type
 e1 <- h2o::h2o.predict(ModelDRLE, test) %>% as.data.frame()
# 
# # predicted value to write
my_output <- e1  %>% dplyr::select(predict) %>% 
  dplyr::bind_cols(drl_exit_data) %>% 
  dplyr::select(predict, X7) %>% 
  # filter only those that must be closed
  dplyr::filter(predict == 'CLOSE') %$% 
  # extract column X7 as a vector
  X7 %>% as.character()
# 
# # Join data to the predicted class
# # get predicted confidence
# my_output_conf <- e1 %>% select(-1) %>% select(which.max(.))
# 
# 
# # Return the name of the output
# names(my_output) <- SYMB
# # Add prediction confidence for diagnostics / robot logic purposes
# my_output <- my_output %>% bind_cols(my_output_conf)
# 
# # write the result to the file
 #write_csv(my_output, file.path(path_terminal, paste0("RLUnitOut", SYMB, "Exit.csv")))
 writeLines(my_output, file.path(path_terminal, paste0("RLUnitOut", SYMB, "Exit.csv")))
 writeLines(my_output, file.path(path_sbxs, paste0("RLUnitOut", SYMB, "Exit.csv")))
 

# 

 }  #end of if condition (not empty data for DL model)


} #end of for loop for SYMB

Sys.sleep(5)
# shutdown the virtual machine
h2o.shutdown(prompt = F)


end_run <- Sys.time()
tot_run <- end_run - start_run
print(tot_run) #Time difference of  secs

#### End